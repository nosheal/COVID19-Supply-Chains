---
title: "Geocoding and Maping"
author: "Nikhil Kalathil"
date: "5/4/2020"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    theme: flatly
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include = FALSE}
#install.packages('ggmap', 'RJSONIO')
library(tidyverse)
library(ggmap)
library(leaflet)
library(leaflet.extras)
library(htmltools)
library(htmlwidgets)
library(RJSONIO)
library(readxl)
library(widgetframe)
```

# Geocoding

In this file we will define a procedure for geolocating entitites based on a csv of their addresses. 

## Swabs

We start by loading our data. 
```{r}
us_swabs_hq <- read_xlsx("swabs_us.xlsx")
```

We then begin the process of geocoding. We will use [Google's geolocating service](https://developers.google.com/maps/documentation/geocoding/intro) to process our geolocation requests. To use this service, we need to get an [API key](https://developers.google.com/maps/documentation/geocoding/get-api-key)

```{r, echo = FALSE, Include = FALSE}
api_key <- c("YOUR_KEY")
```

We define our function, which will take an address as an input and output a latitude and longitude result. 

```{r}
geocodeAddress <- function(address) {
  require(RJSONIO)
  url <- "https://maps.googleapis.com/maps/api/geocode/json?address="
  url <- URLencode(paste(url, address, sep = ""))
  url <- URLencode(paste(url, "&key=", api_key, sep = ""))
  x <- fromJSON(url, simplify = FALSE)
  print(x$status)
  if (x$status == "OK") {
    out <- c(x$results[[1]]$geometry$location$lng,
             x$results[[1]]$geometry$location$lat,
             x$results[[1]]$formatted_address)
  } else {
    out <- NA
  }
  Sys.sleep(0.2)  # API only allows 5 requests per second
  out
}
```

To get the geocode for an address, we pass the address to the function. 

```{r}
geocodeAddress("Time Square, New York City")
```

```{r}
us_swabs_hq <- us_swabs_hq %>% 
  rename(Location = Headquarters) %>% 
  mutate(address = paste(Company, Location, sep = ", ")) %>% 
  mutate(product = "Swabs", purpose = "Testing", loc_desc = "Company HQ") %>% 
  mutate(swabs = case_when(
    Company %in% c("Copan","Becton, Dickinson and Company (BD)", "Fisher Healthcare") ~ "Nasopharyngeal and Oropharyngeal Swabs", 
    Company %in% c("Quidel") ~ "Nasopharyngeal Swabs", 
    Company %in% c("Puritan Medical Products") ~ "Nasopharyngeal, Oropharyngeal, and Other Swabs"
  )) %>% 
  rename(employees = "Number of Employees", sales = "Annual Sales")
```

Let us test that this works with the first entry in our dataframe. 

```{r}
geocodeAddress(us_swabs_hq$address[1])
```

We can confirm that this is the approximate location through google. 

```{r geolocation_check, fig.fullwidth=TRUE, echo = FALSE}
knitr::include_graphics("geolocation checking.png")
```

Now we loop through the addresses to get the latitude and longitude of each address and add it to the original address data frame in the  new columns lat and long. 

```{r}
origAddress <- us_swabs_hq
```


```{r}
for(i in 1:nrow(origAddress))
{
  result <- geocodeAddress(origAddress$address[i])
  origAddress$long[i] <- as.numeric(result[1])
  origAddress$lat[i] <- as.numeric(result[2])
  origAddress$form_address[i] <- as.character(result[3])

}
```


Save this as a new object to prepare for leaflet plotting. In doing so we want to define as identifying factors for this layer as possible. At the minimum, we want to identify the product, purpose, and level in the supply chain. 

```{r}
geocoded_us_swabs_hq <- origAddress 
```

## Nonwoven Fabrics 

We then add another layer of data to test our layering. 

```{r}
top_nonwoven <- read_xlsx("nonwoven_us.xlsx")
```

```{r}
top_nonwoven <- top_nonwoven %>%
  rename(Company = `Company Name`) %>% 
  mutate(address = paste(Company, Location, sep = ", ")) %>% 
  mutate(product = "Nonwoven Fabric", purpose = "Medical Masks", loc_desc = "Company HQ") %>% 
  rename(sales = 'Estimated Annual Revenue')
```


```{r}
for (i in c(1,4,5,8,9,10))
{
  top_nonwoven$address[i] <- paste(top_nonwoven$address[i], "USA", sep = ", ")
}
                                   

```


```{r}
origAddress <- top_nonwoven
```



```{r}
for(i in 1:nrow(origAddress))
{
  result <- geocodeAddress(origAddress$address[i])
  origAddress$long[i] <- as.numeric(result[1])
  origAddress$lat[i] <- as.numeric(result[2])
  origAddress$form_address[i] <- as.character(result[3])
}
```

```{r}
geocoded_global_nonwoven <- origAddress
```
# Mapping 

## Set up dependencies

Now, we can turn to using leaflet to plot these locations.

We first define tools that will let us control the layers of our map. 

```{r}
#grouped layer control plugin
groupedLayerControlPlugin <- htmlDependency("leaflet-groupedlayercontrol", "0.61",
    src = c(href = "http://ismyrnow.github.io/leaflet-groupedlayercontrol/src/"),
    script = "leaflet.groupedlayercontrol.js",
    stylesheet = "leaflet.groupedlayercontrol.css"
)
```

```{r}
fontawesomePlugin <- htmlDependency("fontawesome", "5.13.0",
                                    src = c(href = "https://use.fontawesome.com/releases/v5.13.0"),
                                    stylesheet = "css/all.css"
)
```

```{r}
addDependencies <- function(map) {
  map$dependencies <- c(map$dependencies, leafletDependencies$easyButton(),
                                          leafletDependencies$fontawesome())
  
  map
}
```

```{r}
# A function that takes a plugin htmlDependency object and adds
# it to the map. This ensures that however or whenever the map
# gets rendered, the plugin will be loaded into the browser.
registerPlugin <- function(map, plugin) {
    map$dependencies <- c(map$dependencies, list(plugin))
    map
}
```

```{r}
# Function for creating circle markers given a data set
createCircleMarkersWithData <- function(map, dataSet, clusterId, group, fillColor, icon) {
  jsFuncStr = str_replace_all(str_interp("
    function(cluster) {
      var childCount = cluster.getChildCount();
      return new L.DivIcon({
                                               html: '<div style=\"background-color:${fillColor}; color: white\"><span>' + cluster.getChildCount() + '</div><span>',
                                               className: 'marker-cluster', iconSize: new L.Point(40, 40)
                                             });
    }", list(fillColor = fillColor)), "[\r\n]" , "")
  addAwesomeMarkers(map,
                   popup = dataSet$popup,
                   icon = awesomeIcons(
                     icon = icon,
                     library = "fa",
                     markerColor = fillColor,
                     iconColor = "#ffffff"
                   ),
                   clusterOptions = markerClusterOptions(
                      iconCreateFunction = JS(jsFuncStr)
                   ),
                   clusterId = clusterId,
                   layerId = dataSet$layerId,
                   group = group)
}
```

## Prepare Data 

```{r}
df_for_maps <- bind_rows(geocoded_us_swabs_hq, geocoded_global_nonwoven) %>% 
  select(-"...1")
```

```{r}
#Setup popups and individual layer dataframes
us_swabs <- geocoded_us_swabs_hq %>% 
  mutate(layerId = paste('us_swabs', row_number(), sep = '.'),
                      popup = paste("Product:", geocoded_us_swabs_hq$product, "<br>",
                                 "Purpose:", geocoded_us_swabs_hq$purpose, "<br>",
                                 "Location Type:", geocoded_us_swabs_hq$loc_desc, "<br>",
                     "Company Name:", geocoded_us_swabs_hq$`Company`, "<br>",
                                 "Swabs:", 
                     geocoded_us_swabs_hq$swabs, "<br>",
                                 "Number of Employees:", geocoded_us_swabs_hq$employees, "<br>",
                                 "Annual Sales", geocoded_us_swabs_hq$sales, "<br>"))

global_nonwoven <- geocoded_global_nonwoven %>% 
  mutate(layerId = paste('global_nonwoven', row_number(), sep = '.'), 
         popup = paste("Product:", product, "<br>",
                                 "Purpose:", purpose, "<br>",
                                 "Location Type:", loc_desc, "<br>",
                     "Company Name:", `Company`, "<br>",
                                 "Annual Sales", sales, "<br>"))
```

## Define Colors 
```{r}
sc_color <- colorFactor(c("purple", "darkred"), domain = df_for_maps$purpose)
```

## Map 

```{r}
m <- leaflet(data = df_for_maps) %>% 
  # add layers of maps (decided to provide three options)
  addProviderTiles(providers$Stamen.TonerLite, group = "Toner Lite") %>%
  registerPlugin(groupedLayerControlPlugin) %>%
  registerPlugin(fontawesomePlugin) %>%
  
  onRender("function(el, x, data) {
        var baseLayers = {
            'Toner Lite': this.layerManager.getLayerGroup('Toner Lite'),
        };

        var groupedOverlays = {
            'Testing': {
                'Swabs': this.layerManager.getLayerGroup('Swabs'),
            },
            'Masks': {
                'Nonwoven Fabrics': this.layerManager.getLayerGroup('Nonwoven Fabric'),
            }
        };
        
        var Options = {
          groupCheckboxes: true
        };

        console.log(L.control.groupedLayers);
        L.control.groupedLayers(baseLayers, groupedOverlays, Options).addTo(this);
    }", data = df_for_maps) %>%
  # set the boundary of the map so that the user cannot zoom out of one world 
    # view of the map
    setMaxBounds(lng1 = 210,
                 lat1 = 89.45016124669523,
                 lng2 = -210,
                 lat2 = -87.71179927260242) %>%
    
    # add mini map on bottom right corner with collapse option
    addMiniMap(
        tiles = providers$Stamen.TonerLite,
        toggleDisplay = T
    ) %>%
  
  #1. Swabs
  createCircleMarkersWithData(dataSet = us_swabs,
                              fillColor = "darkred",
                              icon = "fa-syringe",
                              clusterId = "domSwabs",
                              group = "Swabs") %>%
  #2. Nonwoven Fabrics
  createCircleMarkersWithData(dataSet = global_nonwoven,
                              fillColor = "purple",
                              icon = "fa-head-side-mask",
                              clusterId = "glblNonWoven",
                              group = "Nonwoven Fabric") %>%
  # add button that zooms out to zoom level 1 of the map (showing the entire world map)
  addEasyButton(easyButton(
    icon = "fa-globe",
    title = "Zoom to Level 1",
    onClick = JS("
                 function(btn, map) {
                 map.setZoom(1);
                 }")
		)
    ) %>% 

     #add layer control option for clusters and map type 
    #addLayersControl(
      #baseGroups = c("OSM(Default)", "Google", "Toner Lite", "NatGeoWorldMap"),
       #overlayGroups = c("Swabs", "Nonwoven Fabrics"),
        # collapsable table
       # options = layersControlOptions(collapsed = TRUE)
    #) %>% 
    # add legend (table) that shows which color represents which country of origin (color key) - bottom left (due to mini map)
  addLegend(position = c("bottomleft"),
            values = df_for_maps$purpose,
            pal = sc_color,
            title = "Purpose"
  ) 
```

```{r}
saveWidget(m, "prototype.html")
```

